<style>
  /* Global styles */
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  /* Intro block at the top */
  .intro-block {
    width: 500px;
    height: 200px; /* Adjusted height */
    background-color: #EEEEEE;
    margin: 0 auto 20px;
    padding: 1rem;
    border-radius: 10px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
    text-align: center;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
  }
  .intro-block h3 {
    font-size: 40px;
    margin-bottom: 0.5rem;
    color: #333;
  }
  .intro-block p {
    font-size: 0.95rem;
    color: #555;
    line-height: 1.4;
    margin: 0;
  }

  /* Controls row */
  .controls {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
    margin-bottom: 20px;
  }

  /* Glossy button styles */
  .glossy-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    height: 40px;
    padding: 0 10px;
    border: 1px solid #aaa;
    border-radius: 5px;
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.4), 0 2px 5px rgba(0, 0, 0, 0.2);
    background: linear-gradient(to bottom, #bbbbbb 0%, #999999 100%);
    transition: background 0.3s, box-shadow 0.3s;
  }
  .glossy-button:hover {
    background: linear-gradient(to bottom, #cccccc 0%, #aaaaaa 100%);
  }

  /* Recorder section */
  .recorder-section {
    max-width: 600px;
    margin: 30px auto;
    padding: 20px;
    max-height: 200px; /* Adjusted height */
    text-align: center;
    display: flex;
    flex-direction: column;
    justify-content: center;
  }

  .recorder-buttons {
    margin-top: 5px;
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
  }

  .recorder-icon-btn {
    font-size: 20px;
    width: 40px;
    height: 40px;
    color: #fff;
    border: 1px solid #aaa;
    border-radius: 5px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    text-decoration: none;
    transition: background 0.3s, box-shadow 0.3s;
  }

  .recorder-icon-btn:hover {
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6), 0 2px 6px rgba(0, 0, 0, 0.25);
  }

  .start-btn {
    background: linear-gradient(to bottom, #ff4444 0%, #dd0000 100%);
  }
  .stop-btn {
    background: linear-gradient(to bottom, #ffffff 0%, #dddddd 100%);
    color: #000;
  }
  .stop-btn:hover {
    background: linear-gradient(to bottom, #ffffff 0%, #cccccc 100%);
  }

  /* Waveform canvas */
  #waveformCanvas {
    display: block;
    background: #EEE;
    border-radius: 5px;
    margin-top: 8px;
  }
</style>

<script>
  let isRecording = false;
  let mediaStream, mediaRecorder, chunks = [], audioContext, analyser, dataArray, animationId;

  async function startRecording() {
    if (isRecording) return;
    isRecording = true;
    chunks = [];

    try {
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      audioContext = new AudioContext();
      analyser = audioContext.createAnalyser();
      const mediaStreamSource = audioContext.createMediaStreamSource(mediaStream);
      mediaStreamSource.connect(analyser);

      analyser.fftSize = 512;
      dataArray = new Uint8Array(analyser.frequencyBinCount);

      mediaRecorder = new MediaRecorder(mediaStream);
      mediaRecorder.ondataavailable = e => {
        if (e.data.size > 0) chunks.push(e.data);
      };

      mediaRecorder.onstop = () => {
        const blob = new Blob(chunks, { type: 'audio/webm' });
        const url = URL.createObjectURL(blob);
        const downloadContainer = document.getElementById('downloadContainer');
        downloadContainer.innerHTML = '';
        const link = document.createElement('a');
        link.href = url;
        link.download = 'recording.webm';
        link.textContent = 'Download Recording';
        downloadContainer.appendChild(link);
      };

      mediaRecorder.start();
      drawWaveform();
    } catch (err) {
      console.error('Error accessing microphone:', err);
      alert('Error accessing mic. Use HTTPS or check console for details.');
      isRecording = false;
    }
  }

  function stopRecording() {
    if (!isRecording) return;
    isRecording = false;

    mediaStream.getTracks().forEach(track => track.stop());
    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
      mediaRecorder.stop();
    }

    cancelAnimationFrame(animationId);
    if (audioContext) audioContext.close();
  }

  function drawWaveform() {
    const canvas = document.getElementById('waveformCanvas');
    const canvasCtx = canvas.getContext('2d');
    animationId = requestAnimationFrame(drawWaveform);

    analyser.getByteTimeDomainData(dataArray);
    canvasCtx.fillStyle = '#EEE';
    canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

    canvasCtx.lineWidth = 2;
    canvasCtx.strokeStyle = '#007BFF';
    canvasCtx.beginPath();

    const sliceWidth = canvas.width / dataArray.length;
    let x = 0;
    for (let i = 0; i < dataArray.length; i++) {
      const v = dataArray[i] / 128.0;
      const y = v * (canvas.height / 2);
      if (i === 0) {
        canvasCtx.moveTo(x, y);
      } else {
        canvasCtx.lineTo(x, y);
      }
      x += sliceWidth;
    }
    canvasCtx.lineTo(canvas.width, canvas.height / 2);
    canvasCtx.stroke();
  }
</script>
